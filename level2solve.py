import json
import sys
import os

def load_json(path):
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading {path}: {e}")
        sys.exit(1)

def get_point_map(data):
    """
    构建 ID 到 网格坐标 的映射。
    坐标会被除以 40 并四舍五入为整数。
    """
    pmap = {}
    for p in data.get('points', []):
        # Round to nearest integer grid coordinate
        x = int(round(p['x'] / 40.0))
        y = int(round(p['y'] / 40.0))
        pmap[p['id']] = (x, y)
    return pmap

def get_stick_signature(stick, pmap):
    """
    获取杆件的唯一签名: ((x0, y0), (x1, y1), material)
    点坐标会排序以保证方向无关性。
    """
    p0 = pmap.get(stick['point0_id'])
    p1 = pmap.get(stick['point1_id'])
    if not p0 or not p1:
        return None
    
    # Sort points to ensure consistent signature
    pts = sorted([p0, p1])
    mat = stick.get('material', 'road')
    return (pts[0], pts[1], mat)

def main():
    if len(sys.argv) < 3:
        print("Usage: python level2solve.py <level_file> <solved_file> [output_file]")
        print("Example: python level2solve.py files/level5.level files/solve5.level frame/solve5.py")
        return

    level_path = sys.argv[1]
    solved_path = sys.argv[2]
    
    if len(sys.argv) >= 4:
        output_path = sys.argv[3]
    else:
        # 默认输出文件名：solveX.py (在当前目录)
        # 假设 solved_path 是 files/solve5.level，我们提取文件名 solve5
        filename = os.path.splitext(os.path.basename(solved_path))[0]
        output_path = filename + ".py"

    print(f"Reading original level: {level_path}")
    print(f"Reading solved level:   {solved_path}")

    level_data = load_json(level_path)
    solved_data = load_json(solved_path)

    # 1. 构建原始关卡中存在的杆件集合
    level_pmap = get_point_map(level_data)
    level_stick_sigs = set()
    for s in level_data.get('sticks', []):
        sig = get_stick_signature(s, level_pmap)
        if sig:
            level_stick_sigs.add(sig)

    # 2. 查找解决关卡中新增的杆件
    solved_pmap = get_point_map(solved_data)
    new_sticks = []
    
    for s in solved_data.get('sticks', []):
        sig = get_stick_signature(s, solved_pmap)
        if not sig:
            continue
            
        # 检查该杆件是否存在于原始关卡中
        if sig not in level_stick_sigs:
            # 这是一个新杆件
            # 格式化输出: {'p0': [x, y], 'p1': [x, y], 'material': '...'}
            # 注意: sig 是 ((x0, y0), (x1, y1), mat)
            p0, p1, mat = sig
            new_sticks.append({
                'p0': [p0[0], p0[1]],
                'p1': [p1[0], p1[1]],
                'material': mat
            })

    print(f"Found {len(new_sticks)} new sticks.")

    # 3. 写入输出文件
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("# Generated by level2solve.py\n")
            f.write(f"# Source: {os.path.basename(solved_path)}\n")
            f.write("# Contains sticks added in the solution\n\n")
            f.write("sticks = [\n")
            for s in new_sticks:
                # 使用 json.dumps 格式化字典，确保双引号等格式正确
                f.write(f"    {json.dumps(s)},\n")
            f.write("]\n")
        
        print(f"Successfully written to {output_path}")
    except Exception as e:
        print(f"Error writing to {output_path}: {e}")

if __name__ == "__main__":
    main()
